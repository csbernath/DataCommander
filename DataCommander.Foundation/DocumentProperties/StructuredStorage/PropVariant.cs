// <auto-generated />
namespace DataCommander.Foundation.DocumentProperties
{
    using System;
    using System.Runtime.InteropServices;

    /// <summary>
    /// Represents the OLE struct PROPVARIANT.
    /// </summary>
    /// <remarks>
    /// Must call Clear when finished to avoid memory leaks. If you get the value of
    /// a VT_UNKNOWN prop, an implicit AddRef is called, thus your reference will
    /// be active even after the PropVariant struct is cleared.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential)]
    internal struct PropVariant
    {
        #region struct fields

        // The layout of these elements needs to be maintained.
        //
        // NOTE: We could use LayoutKind.Explicit, but we want
        //       to maintain that the IntPtr may be 8 bytes on
        //       64-bit architectures, so we'll let the CLR keep
        //       us aligned.
        //
        // NOTE: In order to allow x64 compat, we need to allow for
        //       expansion of the IntPtr. However, the BLOB struct
        //       uses a 4-byte int, followed by an IntPtr, so
        //       although the p field catches most pointer values,
        //       we need an additional 4-bytes to get the BLOB
        //       pointer. The p2 field provides this, as well as
        //       the last 4-bytes of an 8-byte value on 32-bit
        //       architectures.

        // This is actually a VarEnum value, but the VarEnum type
        // shifts the layout of the struct by 4 bytes instead of the
        // expected 2.
        ushort vt;
        ushort wReserved1;
        ushort wReserved2;
        ushort wReserved3;
        IntPtr p;
        int p2;

        #endregion // struct fields

        #region union members

        sbyte cVal // CHAR cVal;
            => (sbyte) this.GetDataBytes()[0];

        byte bVal // UCHAR bVal;
            => this.GetDataBytes()[0];

        short iVal // SHORT iVal;
            => BitConverter.ToInt16(this.GetDataBytes(), 0);

        ushort uiVal // USHORT uiVal;
            => BitConverter.ToUInt16(this.GetDataBytes(), 0);

        int lVal // LONG lVal;
            => BitConverter.ToInt32(this.GetDataBytes(), 0);

        uint ulVal // ULONG ulVal;
            => BitConverter.ToUInt32(this.GetDataBytes(), 0);

        long hVal // LARGE_INTEGER hVal;
            => BitConverter.ToInt64(this.GetDataBytes(), 0);

        ulong uhVal // ULARGE_INTEGER uhVal;
            => BitConverter.ToUInt64(this.GetDataBytes(), 0);

        float fltVal // FLOAT fltVal;
            => BitConverter.ToSingle(this.GetDataBytes(), 0);

        double dblVal // DOUBLE dblVal;
            => BitConverter.ToDouble(this.GetDataBytes(), 0);

        bool boolVal // VARIANT_BOOL boolVal;
            => (this.iVal == 0 ? false : true);

        int scode // SCODE scode;
            => this.lVal;

        decimal cyVal // CY cyVal;
            => decimal.FromOACurrency(this.hVal);

        DateTime date // DATE date;
            => DateTime.FromOADate(this.dblVal);

        #endregion // union members

        /// <summary>
        /// Gets a byte array containing the data bits of the struct.
        /// </summary>
        /// <returns>A byte array that is the combined size of the data bits.</returns>
        private byte[] GetDataBytes()
        {
            var ret = new byte[IntPtr.Size + sizeof(int)];
            if (IntPtr.Size == 4)
            {
                BitConverter.GetBytes(this.p.ToInt32()).CopyTo(ret, 0);
            }
            else if (IntPtr.Size == 8)
            {
                BitConverter.GetBytes(this.p.ToInt64()).CopyTo(ret, 0);
            }
            BitConverter.GetBytes(this.p2).CopyTo(ret, IntPtr.Size);
            return ret;
        }

        /// <summary>
        /// Called to properly clean up the memory referenced by a PropVariant instance.
        /// </summary>
        [DllImport("ole32.dll")]
        private static extern int PropVariantClear(ref PropVariant pvar);

        /// <summary>
        /// Called to clear the PropVariant's referenced and local memory.
        /// </summary>
        /// <remarks>
        /// You must call Clear to avoid memory leaks.
        /// </remarks>
        public void Clear()
        {
            // Can't pass "this" by ref, so make a copy to call PropVariantClear with
            var var = this;
            PropVariantClear(ref var);

            // Since we couldn't pass "this" by ref, we need to clear the member fields manually
            // NOTE: PropVariantClear already freed heap data for us, so we are just setting
            //       our references to null.
            this.vt = (ushort)VarEnum.VT_EMPTY;
            this.wReserved1 = this.wReserved2 = this.wReserved3 = 0;
            this.p = IntPtr.Zero;
            this.p2 = 0;
        }

        /// <summary>
        /// Gets the variant type.
        /// </summary>
        public VarEnum Type => (VarEnum) this.vt;

        /// <summary>
        /// Gets the variant value.
        /// </summary>
        public object Value
        {
            get
            {
                // TODO: Add support for reference types (ie. VT_REF | VT_I1)
                // TODO: Add support for safe arrays

                switch ((VarEnum) this.vt)
                {
                    case VarEnum.VT_I1:
                        return this.cVal;
                    case VarEnum.VT_UI1:
                        return this.bVal;
                    case VarEnum.VT_I2:
                        return this.iVal;
                    case VarEnum.VT_UI2:
                        return this.uiVal;
                    case VarEnum.VT_I4:
                    case VarEnum.VT_INT:
                        return this.lVal;
                    case VarEnum.VT_UI4:
                    case VarEnum.VT_UINT:
                        return this.ulVal;
                    case VarEnum.VT_I8:
                        return this.hVal;
                    case VarEnum.VT_UI8:
                        return this.uhVal;
                    case VarEnum.VT_R4:
                        return this.fltVal;
                    case VarEnum.VT_R8:
                        return this.dblVal;
                    case VarEnum.VT_BOOL:
                        return this.boolVal;
                    case VarEnum.VT_ERROR:
                        return this.scode;
                    case VarEnum.VT_CY:
                        return this.cyVal;
                    case VarEnum.VT_DATE:
                        return this.date;
                    case VarEnum.VT_FILETIME:
                        return DateTime.FromFileTime(this.hVal);
                    case VarEnum.VT_BSTR:
                        return Marshal.PtrToStringBSTR(this.p);
                    case VarEnum.VT_BLOB:
                        var blobData = new byte[this.lVal];
                        IntPtr pBlobData;
                        if (IntPtr.Size == 4)
                        {
                            pBlobData = new IntPtr(this.p2);
                        }
                        else if (IntPtr.Size == 8)
                        {
                            // In this case, we need to derive a pointer at offset 12,
                            // because the size of the blob is represented as a 4-byte int
                            // but the pointer is immediately after that.
                            pBlobData = new IntPtr(BitConverter.ToInt64(this.GetDataBytes(), sizeof(int)));
                        }
                        else
                            throw new NotSupportedException();
                        Marshal.Copy(pBlobData, blobData, 0, this.lVal);
                        return blobData;
                    case VarEnum.VT_LPSTR:
                        return Marshal.PtrToStringAnsi(this.p);
                    case VarEnum.VT_LPWSTR:
                        return Marshal.PtrToStringUni(this.p);
                    case VarEnum.VT_UNKNOWN:
                        return Marshal.GetObjectForIUnknown(this.p);
                    case VarEnum.VT_DISPATCH:
                        return this.p;
                    default:
                        throw new NotSupportedException("The type of this variable is not support ('" + this.vt.ToString() + "')");
                }
            }
        }
    }
}